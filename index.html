<!DOCTYPE html>
<html lang="en">

<head>
	<title>Video Colour Visualisation</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>

	<div id="container"></div>
	<div id="shaders">
		<script type="x-shader/x-vertex" id="RGBVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			void main() {

				color = texture2D ( tex, position.xy ).rgb;

				vec4 mvPosition = modelViewMatrix* vec4(color-vec3(.5,.5,.5), 1);

				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;

			}
		</script>

		<script type="x-shader/x-fragment" id="RGBFragmentShader">
			varying vec3 color;

			void main() {
				float l = length( gl_PointCoord - vec2( 0.5, 0.5 ));
				if ( l > 0.475 ) discard;

				gl_FragColor = vec4( color, 1.0 );
			}
		</script>

		<script type="x-shader/x-vertex" id="RGBShadowVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			void main() {

				color = texture2D ( tex, position.xy ).rgb;
				color.g = 0.0;

				vec4 mvPosition = modelViewMatrix* vec4(color-vec3(.5,.5,.5), 1);

				gl_PointSize = 3.0;
				gl_Position = projectionMatrix * mvPosition;

			}
		</script>

		<script type="x-shader/x-fragment" id="RGBShadowFragmentShader">
			varying vec3 color;

			void main() {
				float l = length( gl_PointCoord - vec2( 0.5, 0.5 ));
				if ( l > 0.475 ) discard;

				vec3 newcolor = vec3(0.2,0.2,0.2);

				gl_FragColor = vec4( newcolor, 0.05);
			}
		</script>

		<script type="x-shader/x-vertex" id="RGBDensityVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			void main() {

				color = texture2D ( tex, position.xy ).rgb;


				vec4 mvPosition = modelViewMatrix* vec4(color-vec3(.5,.5,.5), 1);

				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;

			}
		</script>

		<script type="x-shader/x-fragment" id="RGBDensityFragmentShader">
			varying vec3 color;

			void main() {
				float alpha = 0.9;
				vec3 ditheredColor = color * (1.0 / 15.0) - 0.5;

				// vec3 newcolor = color * alpha;
				vec3 newColor = color + ditheredColor;
				vec3 finalColor = clamp(newColor, 0.0, 1.0);

				gl_FragColor = vec4( finalColor, alpha);
			}
		</script>

		<script type="x-shader/x-vertex" id="CIExyYVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			void main() {

				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;

				// convert from xyz to xyY
				float xyzSum = xyz.x + xyz.y + xyz.z;

				float x = xyz.x / xyzSum;
				float y = xyz.y / xyzSum;
				float Y = xyz.y;

				 vec3 XYyPos = vec3(x, Y, y);
				//vec3 XYyPos = //vec3(x, Y, y)/1.5;

				vec4 mvPosition = modelViewMatrix* vec4(XYyPos-vec3(.5,.5,.5), 1);

				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;

			}
		</script>

		<script type="x-shader/x-fragment" id="CIExyYFragmentShader">
			varying vec3 color;

			void main() {
				float l = length( gl_PointCoord - vec2( 0.5, 0.5 ));
				if ( l > 0.475 ) discard;

				gl_FragColor = vec4( color, 1.0 );
			}
		</script>

		<script type="x-shader/x-vertex" id="CIExyYDensityVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			void main() {

				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;

				// convert from xyz to xyY
				float xyzSum = xyz.x + xyz.y + xyz.z;

				float x = xyz.x / xyzSum;
				float y = xyz.y / xyzSum;
				float Y = xyz.y;

				 vec3 XYyPos = vec3(x, Y, y);
				//vec3 XYyPos = //vec3(x, Y, y)/1.5;

				vec4 mvPosition = modelViewMatrix* vec4(XYyPos-vec3(.5,.5,.5), 1);

				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;

			}
		</script>

		<script type="x-shader/x-fragment" id="CIExyYDensityFragmentShader">
			varying vec3 color;

			void main() {
				float alpha = 0.9;
				vec3 ditheredColor = color * (1.0 / 15.0) - 0.5;

				// vec3 newcolor = color * alpha;
				vec3 newColor = color + ditheredColor;
				vec3 finalColor = clamp(newColor, 0.0, 1.0);

				gl_FragColor = vec4( finalColor, alpha);

				//gl_FragColor = vec4( color, 1.0 );
			}
		</script>

		<script type="x-shader/x-vertex" id="CIExyYShadowVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			void main() {

				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;

				// convert from xyz to xyY
				float xyzSum = xyz.x + xyz.y + xyz.z;

				float x = xyz.x / xyzSum;
				float y = xyz.y / xyzSum;
				float Y = xyz.y;

				 vec3 XYyPos = vec3(x, 0.0, y);
				//vec3 XYyPos = //vec3(x, Y, y)/1.5;

				vec4 mvPosition = modelViewMatrix* vec4(XYyPos-vec3(.5,.5,.5), 1);

				gl_PointSize = 3.0;
				gl_Position = projectionMatrix * mvPosition;

			}
		</script>

		<script type="x-shader/x-fragment" id="CIExyYShadowFragmentShader">
			varying vec3 color;

			void main() {
				vec3 newcolor = vec3(0.2,0.2,0.2);

				gl_FragColor = vec4( newcolor, 0.05);
			}
		</script>



		<!-- CIE LAB -->
		<script type="x-shader/x-vertex" id="CIELabVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			float f(float t) {
				float epsilon = 0.008856;
				float kappa = 903.3;
				return t > epsilon ? pow(t, 1.0 / 3.0) : (kappa * t + 16.0) / 116.0;
			}

			void main() {

				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;
				// XYZ to CIE LAB
				const vec3 refWhite = vec3(0.95047, 1.0, 1.08883);

				float xNorm = xyz.x / refWhite.x;
				float yNorm = xyz.y / refWhite.y;
				float zNorm = xyz.z / refWhite.z;

				float L = 116.0 * f(yNorm) - 16.0;
				float a = 500.0 * (f(xNorm) - f(yNorm));
				float b = 200.0 * (f(yNorm) - f(zNorm));

				float Lnorm = L / 100.0;
				float anorm = (a + 128.0) / 256.0;
				float bnorm = (b + 128.0) / 256.0;

				vec3 pos = vec3(Lnorm, anorm, bnorm);

				vec4 mvPosition = modelViewMatrix * vec4(pos-vec3(.5,.5,.5), 1);

				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;

			}
		</script>

		<script type="x-shader/x-fragment" id="CIELabFragmentShader">
			varying vec3 color;

			void main() {
				gl_FragColor = vec4( color, 1.0 );
			}
		</script>

		<script type="x-shader/x-vertex" id="CIELabDensityVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			float f(float t) {
				float epsilon = 0.008856;
				float kappa = 903.3;
				return t > epsilon ? pow(t, 1.0 / 3.0) : (kappa * t + 16.0) / 116.0;
			}

			void main() {

				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;
				// XYZ to CIE LAB
				const vec3 refWhite = vec3(0.95047, 1.0, 1.08883);

				float xNorm = xyz.x / refWhite.x;
				float yNorm = xyz.y / refWhite.y;
				float zNorm = xyz.z / refWhite.z;

				float L = 116.0 * f(yNorm) - 16.0;
				float a = 500.0 * (f(xNorm) - f(yNorm));
				float b = 200.0 * (f(yNorm) - f(zNorm));

				float Lnorm = L / 100.0;
				float anorm = (a + 128.0) / 256.0;
				float bnorm = (b + 128.0) / 256.0;

				vec3 pos = vec3(Lnorm, anorm, bnorm);

				vec4 mvPosition = modelViewMatrix * vec4(pos-vec3(.5,.5,.5), 1);

				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;

			}
		</script>

		<script type="x-shader/x-fragment" id="CIELabDensityFragmentShader">
			varying vec3 color;

			void main() {
				float alpha = 0.9;
				vec3 ditheredColor = color * (1.0 / 15.0) - 0.5;

				// vec3 newcolor = color * alpha;
				vec3 newColor = color + ditheredColor;
				vec3 finalColor = clamp(newColor, 0.0, 1.0);

				gl_FragColor = vec4( finalColor, alpha);

			}
		</script>

		<script type="x-shader/x-vertex" id="CIELabShadowVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			float f(float t) {
				float epsilon = 0.008856;
				float kappa = 903.3;
				return t > epsilon ? pow(t, 1.0 / 3.0) : (kappa * t + 16.0) / 116.0;
			}

			void main() {

				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;
				// XYZ to CIE LAB
				const vec3 refWhite = vec3(0.95047, 1.0, 1.08883);

				float xNorm = xyz.x / refWhite.x;
				float yNorm = xyz.y / refWhite.y;
				float zNorm = xyz.z / refWhite.z;

				float L = 116.0 * f(yNorm) - 16.0;
				float a = 500.0 * (f(xNorm) - f(yNorm));
				float b = 200.0 * (f(yNorm) - f(zNorm));

				float Lnorm = L / 100.0;
				float anorm = (a + 128.0) / 256.0;
				float bnorm = (b + 128.0) / 256.0;

				vec3 pos = vec3(Lnorm, 0.0, bnorm);

				vec4 mvPosition = modelViewMatrix * vec4(pos-vec3(.5,.5,.5), 1);

				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;

			}
		</script>

		<script type="x-shader/x-fragment" id="CIELabShadowFragmentShader">
			varying vec3 color;

			void main() {
				vec3 newcolor = vec3(0.2,0.2,0.2);

				gl_FragColor = vec4( newcolor, 0.5);
			}
		</script>
	</div>

	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
	  {
		"imports": {
		  "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
		  "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
		}
	  }
	</script>

	<script type="module">
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { FlyControls } from 'three/addons/controls/FlyControls.js';
		import { GUI } from "three/addons/libs/lil-gui.module.min.js";
		// import WEBGL from "three/addons/capabilities/WebGL.js";

		import Stats from 'three/addons/libs/stats.module.js';

		// AR
		import { XRButton } from 'three/addons/webxr/XRButton.js';
		import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
		import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';
		import { OculusHandPointerModel } from 'three/addons/webxr/OculusHandPointerModel.js';
		import { createText } from 'three/addons/webxr/Text2D.js';

		import { World, System, Component, TagComponent, Types } from 'three/addons/libs/ecsy.module.js';

		let container, stats;

		let camera, scene, renderer, controls;

		let points;

		// let RGBVisMesh;

		var context, canvas;
		var plan, plan_ori;

		// GUI
		var gui;

		// VIDEO AND THE ASSOCIATED TEXTURE
		var video, videoTexture;

		var imageProcessing, imageProcessingMaterial;

		class Object3D extends Component { }

		Object3D.schema = {
			object: { type: Types.Ref }
		};

		class Button extends Component { }

		Button.schema = {
			// button states: [resting, pressed, fully_pressed, recovering]
			currState: { type: Types.String, default: 'resting' },
			prevState: { type: Types.String, default: 'resting' },
			pressSound: { type: Types.Ref, default: null },
			releaseSound: { type: Types.Ref, default: null },
			restingY: { type: Types.Number, default: null },
			surfaceY: { type: Types.Number, default: null },
			recoverySpeed: { type: Types.Number, default: 0.4 },
			fullPressDistance: { type: Types.Number, default: null },
			action: { type: Types.Ref, default: () => { } }
		};

		class ButtonSystem extends System {

			init(attributes) {

				this.renderer = attributes.renderer;
				this.soundAdded = false;

			}

			execute( /*delta, time*/) {

				let buttonPressSound, buttonReleaseSound;
				if (this.renderer.xr.getSession() && !this.soundAdded) {

					const xrCamera = this.renderer.xr.getCamera();

					const listener = new THREE.AudioListener();
					xrCamera.add(listener);

					// create a global audio source
					buttonPressSound = new THREE.Audio(listener);
					buttonReleaseSound = new THREE.Audio(listener);

					// load a sound and set it as the Audio object's buffer
					const audioLoader = new THREE.AudioLoader();
					audioLoader.load('sounds/button-press.ogg', function (buffer) {

						buttonPressSound.setBuffer(buffer);

					});
					audioLoader.load('sounds/button-release.ogg', function (buffer) {

						buttonReleaseSound.setBuffer(buffer);

					});
					this.soundAdded = true;

				}

				this.queries.buttons.results.forEach(entity => {

					const button = entity.getMutableComponent(Button);
					const buttonMesh = entity.getComponent(Object3D).object;
					// populate restingY
					if (button.restingY == null) {

						button.restingY = buttonMesh.position.y;

					}

					if (buttonPressSound) {

						button.pressSound = buttonPressSound;

					}

					if (buttonReleaseSound) {

						button.releaseSound = buttonReleaseSound;

					}

					if (button.currState == 'fully_pressed' && button.prevState != 'fully_pressed') {

						if (button.pressSound) button.pressSound.play();
						button.action();

					}

					if (button.currState == 'recovering' && button.prevState != 'recovering') {

						if (button.releaseSound) button.releaseSound.play();

					}

					// preserve prevState, clear currState
					// FingerInputSystem will update currState
					button.prevState = button.currState;
					button.currState = 'resting';

				});

			}

		}

		ButtonSystem.queries = {
			buttons: {
				components: [Button]
			}
		};

		class Pressable extends TagComponent { }

		class FingerInputSystem extends System {

			init(attributes) {

				this.hands = attributes.hands;

			}

			execute(delta/*, time*/) {

				this.queries.pressable.results.forEach(entity => {

					const button = entity.getMutableComponent(Button);
					const object = entity.getComponent(Object3D).object;
					const pressingDistances = [];
					this.hands.forEach(hand => {

						if (hand && hand.intersectBoxObject(object)) {

							const pressingPosition = hand.getPointerPosition();
							pressingDistances.push(button.surfaceY - object.worldToLocal(pressingPosition).y);

						}

					});
					if (pressingDistances.length == 0) { // not pressed this frame

						if (object.position.y < button.restingY) {

							object.position.y += button.recoverySpeed * delta;
							button.currState = 'recovering';

						} else {

							object.position.y = button.restingY;
							button.currState = 'resting';

						}

					} else {

						button.currState = 'pressed';
						const pressingDistance = Math.max(pressingDistances);
						if (pressingDistance > 0) {

							object.position.y -= pressingDistance;

						}

						if (object.position.y <= button.restingY - button.fullPressDistance) {

							button.currState = 'fully_pressed';
							object.position.y = button.restingY - button.fullPressDistance;

						}

					}

				});

			}

		}

		FingerInputSystem.queries = {
			pressable: {
				components: [Pressable]
			}
		};

		class Draggable extends Component { }

		Draggable.schema = {
			// draggable states: [detached, hovered, to-be-attached, attached, to-be-detached]
			state: { type: Types.String, default: 'none' },
			originalParent: { type: Types.Ref, default: null },
			attachedPointer: { type: Types.Ref, default: null },
			attachedPointer2: { type: Types.Ref, default: null }
		};

		class DraggableSystem extends System {

			execute( /*delta, time*/) {

				this.queries.draggable.results.forEach(entity => {

					const draggable = entity.getMutableComponent(Draggable);
					const object = entity.getComponent(Object3D).object;
					if (draggable.originalParent == null) {

						draggable.originalParent = object.parent;

					}

					switch (draggable.state) {

						case 'to-be-attached':
							draggable.attachedPointer.children[0].attach(object);
							draggable.state = 'attached';
							break;
						case 'to-be-detached':
							draggable.originalParent.attach(object);
							draggable.state = 'detached';
							break;
						default:
							object.scale.set(1, 1, 1);

					}

				});

			}

		}

		DraggableSystem.queries = {
			draggable: {
				components: [Draggable]
			}
		};


		// Scalable
		class Scalable extends Component { }

		Scalable.schema = {
			// Scalable states: [detached, to-be-scaled, scaled, to-be-detached]

			state: { type: Types.String, default: 'none' },
			originalParent: { type: Types.Ref, default: null },
			attachedPointer: { type: Types.Ref, default: null },
			attachedPointer2: { type: Types.Ref, default: null },
			initialHandDistance: { type: Types.Number, default: 0 },
			initialScale: { type: Types.Number, default: 0 },
			currentHandDistance: { type: Types.Number, default: 0 }
		};

		class ScalableSystem extends System {

			execute( /*delta, time*/) {

				this.queries.scalable.results.forEach(entity => {

					const scalable = entity.getMutableComponent(Scalable);
					const object = entity.getComponent(Object3D).object;
					if (scalable.originalParent == null) {

						scalable.originalParent = object.parent;

					}

					switch (scalable.state) {

						case 'to-be-attached':
							console.log('to-be-attached')
							if (scalable.attachedPointer2) {
								scalable.attachedPointer2.children[0].attach(object);
							} else {
								scalable.attachedPointer.children[0].attach(object);
							}
							scalable.state = 'attached';
							break;
						case 'to-be-detached':
							console.log('to-be-detached')

							scalable.originalParent.attach(object);
							scalable.state = 'detached';
							break;
						case 'to-be-scaled':
							console.log('to-be-scaled')

							scalable.attachedPointer2.children[0].attach(object);
							scalable.state = 'scaled';
							break;
						case 'scaled':

							const newScale = scalable.initialScale * (scalable.currentHandDistance / scalable.initialHandDistance);
							object.scale.setScalar(newScale);
							break;
						default:
						// object.scale.set(1, 1, 1);

					}

				});

			}

		}

		ScalableSystem.queries = {
			scalable: {
				components: [Scalable]
			}
		};

		class Intersectable extends TagComponent { }

		class HandRaySystem extends System {

			init(attributes) {

				this.handPointers = attributes.handPointers;
				this.mostRecentScalable = null;

			}

			getDistance(intersections) {
				console.log('getDistanceENter');
				var hp1 = this.handPointers[0].joints['index-finger-tip'];
				var hp2 = this.handPointers[1].joints['index-finger-tip'];
				let distance = hp1.position.distanceTo(hp2.position);
				console.log('getDistance:', distance);
				return distance;
			}


			execute( /*delta, time*/) {

				this.handPointers.forEach(hp => {

					let distance = null;
					let intersectingEntity = null;
					this.queries.intersectable.results.forEach(entity => {

						const object = entity.getComponent(Object3D).object;
						const intersections = hp.intersectObject(object, false);
						if (intersections && intersections.length > 0) {

							if (distance == null || intersections[0].distance < distance) {

								distance = intersections[0].distance;
								intersectingEntity = entity;

							}

						}

					});
					if (distance) {

						hp.setCursor(distance);
						if (intersectingEntity.hasComponent(Button)) {

							const button = intersectingEntity.getMutableComponent(Button);
							if (hp.isPinched()) {

								button.currState = 'pressed';

							} else if (button.currState != 'pressed') {

								button.currState = 'hovered';

							}

						}

						if (intersectingEntity.hasComponent(Draggable)) {

							const draggable = intersectingEntity.getMutableComponent(Draggable);
							const object = intersectingEntity.getComponent(Object3D).object;
							object.scale.set(1.1, 1.1, 1.1);


							if (hp.isPinched()) {

								if (!hp.isAttached() && draggable.state != 'attached') {
									draggable.state = 'to-be-attached';
									draggable.attachedPointer = hp;
									hp.setAttached(true);
								}


							} else {

								// remove a hand from the object
								if (hp.isAttached() && draggable.state == 'attached') {
									draggable.state = 'to-be-detached';
									draggable.attachedPointer = null;
									hp.setAttached(false);

								}



							}

						}

						if (intersectingEntity.hasComponent(Scalable)) {

							const scalable = intersectingEntity.getMutableComponent(Scalable);
							this.mostRecentScalable = scalable;
							const object = intersectingEntity.getComponent(Object3D).object;
							if (hp.isPinched()) {

								if (!hp.isAttached() && scalable.state != 'attached') {
									console.log('1 hands attached');

									scalable.state = 'to-be-attached';
									scalable.attachedPointer = hp;
									hp.setAttached(true);

								}
								else if (!hp.isAttached() && (scalable.state == 'attached' || scalable.state == 'to-be-attached')) {
									// When pinching with both hands
									scalable.state = 'to-be-scaled';
									scalable.attachedPointer2 = hp;

									var pointerWorldPos = new THREE.Vector3(); // Create a new vector to hold the world position
									this.handPointers[1].cursorObject.getWorldPosition(pointerWorldPos);

									var pointerWorldPos2 = new THREE.Vector3(); // Create a new vector to hold the world position
									this.handPointers[0].cursorObject.getWorldPosition(pointerWorldPos2);

									let distance = (pointerWorldPos2.distanceTo(pointerWorldPos))
									scalable.initialHandDistance = distance;
									scalable.currentHandDistance = distance;

									scalable.initialScale = object.scale.x;
									console.log('2 hands attached, dist:', scalable.initialHandDistance);

									hp.setAttached(true);
								}

								else if (hp.isAttached() && scalable.state == 'scaled') {
									var pointerWorldPos = new THREE.Vector3(); // Create a new vector to hold the world position
									this.handPointers[1].cursorObject.getWorldPosition(pointerWorldPos);

									var pointerWorldPos2 = new THREE.Vector3(); // Create a new vector to hold the world position
									this.handPointers[0].cursorObject.getWorldPosition(pointerWorldPos2);

									scalable.currentHandDistance = (pointerWorldPos2.distanceTo(pointerWorldPos))
								}

								// MAKE SCALING CONDITION AS WELL
							} else {

								if (hp.isAttached() && scalable.state == 'attached') {

									console.log('1 hands removed, no more');
									scalable.state = 'to-be-detached';
									scalable.attachedPointer = null;
									scalable.attachedPointer2 = null;
									hp.setAttached(false);

								}

								// remove a hand from the object when another hand is attached
								if (hp.isAttached() && scalable.state == 'scaled') {

									console.log('1 hand removed, another still');
									scalable.state = 'to-be-attached';
									if (scalable.attachedPointer == hp) {
										scalable.attachedPointer = null;
									} else {
										scalable.attachedPointer2 = null;
									}
									hp.setAttached(false);
								}
							}
						}

					} else {
						hp.setCursor(1.5);
						// remove all hands from object if scaling procedure moves out of bounds
						if (hp.isAttached() && !hp.isPinched()) {
							let scalable = this.mostRecentScalable

							if (scalable.attachedPointer == hp) {
								scalable.state = 'to-be-detached';
								scalable.attachedPointer = null;
								scalable.attachedPointer2 = null;
								this.handPointers[0].setAttached(false);
								this.handPointers[1].setAttached(false);

							}
						}
					}
				});

			}

		}

		HandRaySystem.queries = {
			intersectable: {
				components: [Intersectable]
			}
		};

		class HandsInstructionText extends TagComponent { }

		class InstructionSystem extends System {

			init(attributes) {

				this.controllers = attributes.controllers;

			}

			execute( /*delta, time*/) {

				let visible = false;
				this.controllers.forEach(controller => {

					if (controller.visible) {

						visible = true;

					}

				});

				this.queries.instructionTexts.results.forEach(entity => {

					const object = entity.getComponent(Object3D).object;
					object.visible = visible;

				});

			}

		}

		InstructionSystem.queries = {
			instructionTexts: {
				components: [HandsInstructionText]
			}
		};

		class OffsetFromCamera extends Component { }

		OffsetFromCamera.schema = {
			x: { type: Types.Number, default: 0 },
			y: { type: Types.Number, default: 0 },
			z: { type: Types.Number, default: 0 },
		};

		class NeedCalibration extends TagComponent { }

		class CalibrationSystem extends System {

			init(attributes) {

				this.camera = attributes.camera;
				this.renderer = attributes.renderer;

			}

			execute( /*delta, time*/) {

				this.queries.needCalibration.results.forEach(entity => {

					if (this.renderer.xr.getSession()) {

						const offset = entity.getComponent(OffsetFromCamera);
						const object = entity.getComponent(Object3D).object;
						const xrCamera = this.renderer.xr.getCamera();
						object.position.x = xrCamera.position.x + offset.x;
						object.position.y = xrCamera.position.y + offset.y;
						object.position.z = xrCamera.position.z + offset.z;
						entity.removeComponent(NeedCalibration);

					}

				});

			}

		}

		CalibrationSystem.queries = {
			needCalibration: {
				components: [NeedCalibration]
			}
		};

		class Randomizable extends TagComponent { }

		class RandomizerSystem extends System {

			init( /*attributes*/) {

				this.needRandomizing = true;

			}

			execute( /*delta, time*/) {

				if (!this.needRandomizing) {

					return;

				}

				this.queries.randomizable.results.forEach(entity => {

					const object = entity.getComponent(Object3D).object;

					object.material.color.setHex(Math.random() * 0xffffff);

					object.position.x = Math.random() * 2 - 1;
					object.position.y = Math.random() * 2;
					object.position.z = Math.random() * 2 - 1;

					object.rotation.x = Math.random() * 2 * Math.PI;
					object.rotation.y = Math.random() * 2 * Math.PI;
					object.rotation.z = Math.random() * 2 * Math.PI;

					object.scale.x = Math.random() + 0.5;
					object.scale.y = Math.random() + 0.5;
					object.scale.z = Math.random() + 0.5;
					this.needRandomizing = false;

				});

			}

		}

		RandomizerSystem.queries = {
			randomizable: {
				components: [Randomizable]
			}
		};

		const world = new World();
		const clock = new THREE.Clock();
		let hand1, hand2, handPointer1, handPointer2;
		let RGBVisMesh, RGBDensityVisMesh, CIExyYVisMesh, CIExyYDensityVisMesh, CIELabVisMesh, CIELabDensityVisMesh;
		let visObject;
		init();
		animate();


		function makeButtonMesh(x, y, z, color) {

			const geometry = new THREE.BoxGeometry(x, y, z);
			const material = new THREE.MeshBasicMaterial({ color: color });
			const buttonMesh = new THREE.Mesh(geometry, material);
			buttonMesh.castShadow = true;
			buttonMesh.receiveShadow = true;
			return buttonMesh;

		}

		function init() {
			// if (WEBGL.isWebGL2Available() === false) {
			// 	document.body.appendChild(WEBGL.getWebGL2ErrorMessage());
			// }

			container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, .1, 50);
			camera.position.y = 1.5;;

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xcccccc);


			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			if (renderer.xr.isPresenting)
				scene.background = new THREE.Color(0x000000)

			container.appendChild(renderer.domElement);

			controls = new FlyControls(camera, renderer.domElement);
			controls.dragToLook = true;
			controls.movementSpeed = 0.1;

			stats = new Stats();
			container.appendChild(stats.dom);

			const axesHelper = new THREE.AxesHelper(5);
			scene.add(axesHelper);

			const loader = new THREE.TextureLoader();

			window.addEventListener('resize', onWindowResize);

			// VR AR Content
			document.body.appendChild(XRButton.createButton(renderer));
			renderer.xr.enabled = true;
			renderer.xr.cameraAutoUpdate = false;

			// controllers
			const controller1 = renderer.xr.getController(0);
			scene.add(controller1);

			const controller2 = renderer.xr.getController(1);
			scene.add(controller2);

			const controllerModelFactory = new XRControllerModelFactory();

			// Hand 1
			const controllerGrip1 = renderer.xr.getControllerGrip(0);
			controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
			scene.add(controllerGrip1);

			hand1 = renderer.xr.getHand(0);
			hand1.add(new OculusHandModel(hand1));
			handPointer1 = new OculusHandPointerModel(hand1, controller1);
			const handModel1 = new OculusHandModel(hand1);
			hand1.add(handModel1);
			hand1.add(handPointer1);
			scene.add(hand1);

			// Hand 2
			const controllerGrip2 = renderer.xr.getControllerGrip(1);
			controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
			scene.add(controllerGrip2);

			hand2 = renderer.xr.getHand(1);
			hand2.add(new OculusHandModel(hand2));
			handPointer2 = new OculusHandPointerModel(hand2, controller2);
			const handModel2 = new OculusHandModel(hand2);
			hand2.add(handModel2);
			hand2.add(handPointer2);
			scene.add(hand2);

			function IVprocess(imageProcessing, renderer) {
				renderer.setRenderTarget(imageProcessing.rtt);
				renderer.render(imageProcessing.scene, imageProcessing.orthoCamera);
				renderer.setRenderTarget(null);
			}

			// VIDEO AND THE ASSOCIATED TEXTURE
			var video, videoTexture;

			var imageProcessing, imageProcessingMaterial;

			video = document.createElement("video");
			video.src = "video.mp4";
			video.load();
			video.muted = true;
			video.loop = true;

			video.onloadeddata = function () {
				videoTexture = new THREE.VideoTexture(video);
				videoTexture.minFilter = THREE.NearestFilter;
				videoTexture.magFilter = THREE.NearestFilter;
				videoTexture.generateMipmaps = false;
				videoTexture.format = THREE.RGBAFormat;

				// VIDEO -------------
				var geometry2 = new THREE.PlaneGeometry(
					1,
					video.videoHeight / video.videoWidth
				);
				imageProcessingMaterial = new THREE.MeshBasicMaterial({
					map: videoTexture,
					side: THREE.DoubleSide,
				});
				plan_ori = new THREE.Mesh(geometry2, imageProcessingMaterial);
				plan_ori.position.y = 1.5;
				plan_ori.position.z = -2.5;

				plan_ori.receiveShadow = false;
				plan_ori.castShadow = false;

				const videoEntity = world.createEntity();
				videoEntity.addComponent(Intersectable);
				// entity.addComponent(Randomizable);
				videoEntity.addComponent(Object3D, { object: plan_ori });
				// videoEntity.addComponent(Draggable);
				videoEntity.addComponent(Scalable);


				scene.add(plan_ori);


				// POINT CLOUD ------

				//GLOBAL
				var boundingBoxGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
				// var wireframe = new THREE.EdgesGeometry(boundingBoxGeo);
				var boundingBox = new THREE.Mesh(boundingBoxGeo, new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.1, depthTest: false }));

				const pointsGeometry = new THREE.BufferGeometry();
				const positions = [];

				var discrete = 5;
				let counter = 0;

				for (let i = 0; i < video.videoHeight; i += discrete)
					for (let j = 0; j < video.videoWidth; j += discrete) {
						// positions
						const x = (i + 0.5) / video.videoHeight;
						const y = (j + 0.5) / video.videoWidth;
						const z = 0;

						positions.push(x, y, z);
						counter++;
					}

				pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
				pointsGeometry.computeBoundingSphere();

				var gridHelper = new THREE.GridHelper(1, 10);
				gridHelper.position.y = -0.5;

				var axesHelper = new THREE.AxesHelper(1);
				axesHelper.position.set(-0.5, -0.5, -0.5)


				function makeVis(vertexShader, fragmentShader, shadowVertexShader, shadowFragmentShader) {

					const thisVisMesh = new THREE.Object3D();

					let blending = THREE.NormalBlending;
					if (vertexShader.includes("Density"))
						blending = THREE.AdditiveBlending;


					var colorSpaceMaterial = new THREE.ShaderMaterial({
						vertexShader: document.getElementById(vertexShader).textContent,
						fragmentShader: document.getElementById(fragmentShader).textContent,
						blending: blending,
						depthTest: true,
						transparent: true,
						uniforms: {
							tex: { value: videoTexture },
						}
					});
					points = new THREE.Points(pointsGeometry, colorSpaceMaterial);

					var shadowSpaceMaterial = new THREE.ShaderMaterial({
						vertexShader: document.getElementById(shadowVertexShader).textContent,
						fragmentShader: document.getElementById(shadowFragmentShader).textContent,
						blending: THREE.NormalBlending,
						depthTest: true,
						transparent: true,

						uniforms: {
							tex: { value: videoTexture },
						}
					});
					let shadowPoints = new THREE.Points(pointsGeometry, shadowSpaceMaterial);
					points.add(shadowPoints)

					thisVisMesh.add(points);

					thisVisMesh.add(gridHelper.clone());
					thisVisMesh.add(axesHelper.clone());

					thisVisMesh.scale.set(0.5, 0.5, 0.5);

					var thisVisMeshBox = boundingBox.clone();

					thisVisMeshBox.add(thisVisMesh);

					const thisVisMeshEntity = world.createEntity();
					thisVisMeshEntity.addComponent(Intersectable);
					thisVisMeshEntity.addComponent(Object3D, { object: thisVisMeshBox });
					// thisVisMeshEntity.addComponent(Draggable);
					thisVisMeshEntity.addComponent(Scalable);

					return thisVisMeshBox;
				}

				visObject = new THREE.Object3D();
				// MESHES FOR EACH VIS
				RGBVisMesh = makeVis('RGBVertexShader', 'RGBFragmentShader', 'RGBShadowVertexShader', 'RGBShadowFragmentShader');
				RGBVisMesh.position.x = 1;
				RGBVisMesh.position.y = 2.5;
				RGBVisMesh.position.z = -2.0
				visObject.add(RGBVisMesh);
				RGBVisMesh.visible = true


				RGBDensityVisMesh = makeVis('RGBDensityVertexShader', 'RGBDensityFragmentShader', 'RGBShadowVertexShader', 'RGBShadowFragmentShader');
				RGBDensityVisMesh.position.x = -1;
				RGBDensityVisMesh.position.y = 2.5;
				RGBDensityVisMesh.position.z = -2.0
				visObject.add(RGBDensityVisMesh);
				RGBDensityVisMesh.visible = false


				CIExyYVisMesh = makeVis('CIExyYVertexShader', 'CIExyYFragmentShader', 'CIExyYShadowVertexShader', 'CIExyYShadowFragmentShader');
				CIExyYVisMesh.position.x = 1;
				CIExyYVisMesh.position.y = 1.5;
				CIExyYVisMesh.position.z = -2.0
				visObject.add(CIExyYVisMesh);
				CIExyYVisMesh.visible = false

				CIExyYDensityVisMesh = makeVis('CIExyYDensityVertexShader', 'CIExyYDensityFragmentShader', 'CIExyYShadowVertexShader', 'CIExyYShadowFragmentShader');
				CIExyYDensityVisMesh.position.x = -1;
				CIExyYDensityVisMesh.position.y = 1.5;
				CIExyYDensityVisMesh.position.z = -2.0
				visObject.add(CIExyYDensityVisMesh);
				CIExyYDensityVisMesh.visible = false

				CIELabVisMesh = makeVis('CIELabVertexShader', 'CIELabFragmentShader', 'CIELabShadowVertexShader', 'CIELabShadowFragmentShader');
				CIELabVisMesh.position.x = 1;
				CIELabVisMesh.position.y = 0.5;
				CIELabVisMesh.position.z = -2.0
				visObject.add(CIELabVisMesh);
				CIELabVisMesh.visible = false

				CIELabDensityVisMesh = makeVis('CIELabDensityVertexShader', 'CIELabDensityFragmentShader', 'CIELabShadowVertexShader', 'CIELabShadowFragmentShader');
				CIELabDensityVisMesh.position.x = -1;
				CIELabDensityVisMesh.position.y = 0.5;
				CIELabDensityVisMesh.position.z = -2.0
				visObject.add(CIELabDensityVisMesh);
				CIELabDensityVisMesh.visible = false

				scene.add(visObject);

				addGUI(imageProcessingMaterial, video);


				video.play();
			};

			// BUTTONS!

			const consoleGeometry = new THREE.BoxGeometry(0.5, 0.12, 0.15);
			const consoleMaterial = new THREE.MeshPhongMaterial({ color: 0x595959 });
			const consoleMesh = new THREE.Mesh(consoleGeometry, consoleMaterial);
			consoleMesh.position.set(0, 1, - 0.3);
			consoleMesh.castShadow = true;
			consoleMesh.receiveShadow = true;
			scene.add(consoleMesh);
			consoleMesh.scale.set(0.5, 0.5, 0.5);

			const rgbButton = makeButtonMesh(0.08, 0.1, 0.08, 0xffd3b5);
			rgbButton.position.set(- 0.15, 0.04, 0);
			const rgbButtonText = createText('RGB', 0.03);
			rgbButton.add(rgbButtonText);
			rgbButtonText.rotation.x = - Math.PI / 2;
			rgbButtonText.position.set(0, 0.051, 0);
			consoleMesh.add(rgbButton);

			const xyYButton = makeButtonMesh(0.08, 0.1, 0.08, 0xe84a5f);
			xyYButton.position.set(-0.05, 0.04, 0);
			const xyYButtonText = createText('xyY', 0.03);
			xyYButton.add(xyYButtonText);
			xyYButtonText.rotation.x = - Math.PI / 2;
			xyYButtonText.position.set(0, 0.051, 0);
			consoleMesh.add(xyYButton);

			const labButton = makeButtonMesh(0.08, 0.1, 0.08, 0x355c7d);
			const labButtonText = createText('Lab', 0.03);
			labButton.add(labButtonText);
			labButtonText.rotation.x = - Math.PI / 2;
			labButtonText.position.set(0, 0.051, 0);
			labButton.position.set(0.05, 0.04, 0);
			consoleMesh.add(labButton);

			const densityButton = makeButtonMesh(0.08, 0.1, 0.08, 0xff0000);
			const densityButtonText = createText('Density', 0.02);
			densityButton.add(densityButtonText);
			densityButtonText.rotation.x = - Math.PI / 2;
			densityButtonText.position.set(0, 0.051, 0);
			densityButton.position.set(0.15, 0.04, 0);
			consoleMesh.add(densityButton);


			// WORLD
			world
				.registerComponent(Object3D)
				.registerComponent(Button)
				.registerComponent(Pressable)
				.registerComponent(Intersectable)
				.registerComponent(HandsInstructionText)
				.registerComponent(OffsetFromCamera)
				.registerComponent(NeedCalibration)
				.registerComponent(Randomizable)
				.registerComponent(Draggable)
				.registerComponent(Scalable);

			world
				.registerSystem(RandomizerSystem)
				.registerSystem(InstructionSystem, { controllers: [controllerGrip1, controllerGrip2] })
				.registerSystem(CalibrationSystem, { renderer: renderer, camera: camera })
				.registerSystem(ButtonSystem, { renderer: renderer, camera: camera })
				.registerSystem(DraggableSystem)
				.registerSystem(ScalableSystem)
				.registerSystem(FingerInputSystem, { hands: [handModel1, handModel2] })
				.registerSystem(HandRaySystem, { handPointers: [handPointer1, handPointer2] });


			let onDensity = false;

			const csEntity = world.createEntity();
			csEntity.addComponent(OffsetFromCamera, { x: 0, y: - 0.4, z: - 0.3 });
			csEntity.addComponent(NeedCalibration);
			csEntity.addComponent(Intersectable);
			csEntity.addComponent(Draggable)
			csEntity.addComponent(Object3D, { object: consoleMesh });

			const obEntity = world.createEntity();
			obEntity.addComponent(Pressable);
			obEntity.addComponent(Intersectable);
			obEntity.addComponent(Object3D, { object: rgbButton });
			const obAction = function () {

				if (onDensity) {
					RGBDensityVisMesh.visible = !RGBDensityVisMesh.visible;
				} else {
					RGBVisMesh.visible = !RGBVisMesh.visible;
				}
			};


			obEntity.addComponent(Button, { action: obAction, surfaceY: 0.05, fullPressDistance: 0.02 });

			const pbEntity = world.createEntity();
			pbEntity.addComponent(Pressable);
			pbEntity.addComponent(Intersectable);
			pbEntity.addComponent(Object3D, { object: xyYButton });
			const pbAction = function () {

				if (!onDensity) {
					CIExyYVisMesh.visible = !CIExyYVisMesh.visible;
				} else {
					CIExyYDensityVisMesh.visible = !CIExyYDensityVisMesh.visible;
				}
			};

			pbEntity.addComponent(Button, { action: pbAction, surfaceY: 0.05, fullPressDistance: 0.02 });

			const rbEntity = world.createEntity();
			rbEntity.addComponent(Pressable);
			rbEntity.addComponent(Intersectable);
			rbEntity.addComponent(Object3D, { object: labButton });
			const rbAction = function () {

				if (!onDensity) {
					CIELabVisMesh.visible = !CIELabVisMesh.visible;
				} else {
					CIELabDensityVisMesh.visible = !CIELabDensityVisMesh.visible;
				}
			};

			rbEntity.addComponent(Button, { action: rbAction, surfaceY: 0.05, fullPressDistance: 0.02 });

			const ebEntity = world.createEntity();
			ebEntity.addComponent(Pressable);
			ebEntity.addComponent(Intersectable);
			ebEntity.addComponent(Object3D, { object: densityButton });
			const ebAction = function () {

				onDensity = !onDensity;

				if (onDensity) {
					if (RGBVisMesh.visible) {
						RGBVisMesh.visible = false;
						RGBDensityVisMesh.visible = true;
					}
					if (CIExyYVisMesh.visible) {
						CIExyYVisMesh.visible = false;
						CIExyYDensityVisMesh.visible = true;
					}
					if (CIELabVisMesh.visible) {
						CIELabVisMesh.visible = false;
						CIELabDensityVisMesh.visible = true;
					}
				} else {
					if (RGBDensityVisMesh.visible) {
						RGBVisMesh.visible = true;
						RGBDensityVisMesh.visible = false;
					}
					if (CIExyYDensityVisMesh.visible) {
						CIExyYVisMesh.visible = true;
						CIExyYDensityVisMesh.visible = false;
					}
					if (CIELabDensityVisMesh.visible) {
						CIELabVisMesh.visible = true;
						CIELabDensityVisMesh.visible = false;
					}
				}

			};

			ebEntity.addComponent(Button, { action: ebAction, surfaceY: 0.05, recoverySpeed: 0.2, fullPressDistance: 0.03 });


			window.addEventListener('resize', onWindowResize);


		}


		function addGUI(imageProcessingMaterial, video) {

			var pausePlayObj = {
				pausePlay: function () {
					if (!video.paused) {
						console.log("pause");
						video.pause();
					} else {
						console.log("play");
						video.play();
					}
				},
				add10sec: function () {
					video.currentTime = video.currentTime + 10;
					console.log(video.currentTime);
				},
			};

			gui = new GUI();
			gui.add(pausePlayObj, "pausePlay").name("Pause/play video");
			gui.add(pausePlayObj, "add10sec").name("Add 10 seconds");

			var colourFolder = gui.addFolder("Colour Visualisations");
			let params = {
				RGBVisMesh: true,
				RGBDensityVisMesh: false,
				CIExyYVisMesh: false,
				CIExyYDensityVisMesh: false,
				CIELabVisMesh: false,
				CIELabDensityVisMesh: false,
			}

			colourFolder.add(params, "RGBVisMesh").name("RGB").onChange(function (value) {
				RGBVisMesh.visible = value;
			});
			colourFolder.add(params, "RGBDensityVisMesh").name("RGB Density").onChange(function (value) {
				RGBDensityVisMesh.visible = value;
			});
			colourFolder.add(params, "CIExyYVisMesh").name("CIExyY").onChange(function (value) {
				CIExyYVisMesh.visible = value;
			});
			colourFolder.add(params, "CIExyYDensityVisMesh").name("CIExyY Density").onChange(function (value) {
				CIExyYDensityVisMesh.visible = value;
			});
			colourFolder.add(params, "CIELabVisMesh").name("CIELab").onChange(function (value) {
				CIELabVisMesh.visible = value;
			});
			colourFolder.add(params, "CIELabDensityVisMesh").name("CIELab Density").onChange(function (value) {
				CIELabDensityVisMesh.visible = value;
			});


		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			// requestAnimationFrame(animate);

			renderer.setAnimationLoop(render);
			// render();
			stats.update();

		}

		function render() {
			if (typeof imageProcessing !== "undefined")
				IVprocess(imageProcessing, renderer);
			controls.update(0.5);

			const delta = clock.getDelta();
			const elapsedTime = clock.elapsedTime;
			renderer.xr.updateCamera(camera);
			world.execute(delta, elapsedTime);
			renderer.render(scene, camera);
		}



	</script>

</body>

</html>