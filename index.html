<!DOCTYPE html>
<html lang="en">

<head>
	<title>Video Colour Visualisation</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>

	<div id="container"></div>
	<div id="shaders">
		<script type="x-shader/x-vertex" id="RGBVertexShader">
			uniform sampler2D tex;
			varying vec3 color;
	
			void main() {
	
				color = texture2D ( tex, position.xy ).rgb;
	
				vec4 mvPosition = modelViewMatrix* vec4(color-vec3(.5,.5,.5), 1);
	
				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
	
			}
		</script>

		<script type="x-shader/x-fragment" id="RGBFragmentShader">
			varying vec3 color;
	
			void main() {
				float l = length( gl_PointCoord - vec2( 0.5, 0.5 ));
				if ( l > 0.475 ) discard;
	
				gl_FragColor = vec4( color, 1.0 );
			}
		</script>

		<script type="x-shader/x-vertex" id="RGBShadowVertexShader">
			uniform sampler2D tex;
			varying vec3 color;
	
			void main() {
	
				color = texture2D ( tex, position.xy ).rgb;
				color.g = 0.0;
	
				vec4 mvPosition = modelViewMatrix* vec4(color-vec3(.5,.5,.5), 1);
	
				gl_PointSize = 3.0;
				gl_Position = projectionMatrix * mvPosition;
	
			}
		</script>

		<script type="x-shader/x-fragment" id="RGBShadowFragmentShader">
			varying vec3 color;
	
			void main() {
				float l = length( gl_PointCoord - vec2( 0.5, 0.5 ));
				if ( l > 0.475 ) discard;
	
				vec3 newcolor = vec3(0.2,0.2,0.2);
	
				gl_FragColor = vec4( newcolor, 0.05);
			}
		</script>

		<script type="x-shader/x-vertex" id="RGBDensityVertexShader">
			uniform sampler2D tex;
			varying vec3 color;
	
			void main() {
	
				color = texture2D ( tex, position.xy ).rgb;
				
	
				vec4 mvPosition = modelViewMatrix* vec4(color-vec3(.5,.5,.5), 1);
	
				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
	
			}
		</script>

		<script type="x-shader/x-fragment" id="RGBDensityFragmentShader">
			varying vec3 color;
	
			void main() {
				float alpha = 0.3;
				vec3 ditheredColor = color * (1.0 / 15.0) - 0.5;

				// vec3 newcolor = color * alpha;
				vec3 newColor = color + ditheredColor;
				vec3 finalColor = clamp(newColor, 0.0, 1.0);

				gl_FragColor = vec4( finalColor, alpha);
			}
		</script>

		<script type="x-shader/x-vertex" id="CIExyYVertexShader">
			uniform sampler2D tex;
			varying vec3 color;
	
			void main() {
	
				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;

				// convert from xyz to xyY
				float xyzSum = xyz.x + xyz.y + xyz.z;

				float x = xyz.x / xyzSum;
				float y = xyz.y / xyzSum;
				float Y = xyz.y;

				 vec3 XYyPos = vec3(x, Y, y);
				//vec3 XYyPos = //vec3(x, Y, y)/1.5;
	
				vec4 mvPosition = modelViewMatrix* vec4(XYyPos-vec3(.5,.5,.5), 1);
	
				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
	
			}
		</script>

		<script type="x-shader/x-fragment" id="CIExyYFragmentShader">
			varying vec3 color;
	
			void main() {
				float l = length( gl_PointCoord - vec2( 0.5, 0.5 ));
				if ( l > 0.475 ) discard;
	
				gl_FragColor = vec4( color, 1.0 );
			}
		</script>

		<script type="x-shader/x-vertex" id="CIExyYDensityVertexShader">
			uniform sampler2D tex;
			varying vec3 color;
	
			void main() {
	
				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;

				// convert from xyz to xyY
				float xyzSum = xyz.x + xyz.y + xyz.z;

				float x = xyz.x / xyzSum;
				float y = xyz.y / xyzSum;
				float Y = xyz.y;

				 vec3 XYyPos = vec3(x, Y, y);
				//vec3 XYyPos = //vec3(x, Y, y)/1.5;
	
				vec4 mvPosition = modelViewMatrix* vec4(XYyPos-vec3(.5,.5,.5), 1);
	
				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
	
			}
		</script>

		<script type="x-shader/x-fragment" id="CIExyYDensityFragmentShader">
			varying vec3 color;
	
			void main() {
				float alpha = 0.3;
				vec3 ditheredColor = color * (1.0 / 15.0) - 0.5;

				// vec3 newcolor = color * alpha;
				vec3 newColor = color + ditheredColor;
				vec3 finalColor = clamp(newColor, 0.0, 1.0);

				gl_FragColor = vec4( finalColor, alpha);
	
				//gl_FragColor = vec4( color, 1.0 );
			}
		</script>

		<script type="x-shader/x-vertex" id="CIExyYShadowVertexShader">
			uniform sampler2D tex;
			varying vec3 color;
	
			void main() {
	
				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;

				// convert from xyz to xyY
				float xyzSum = xyz.x + xyz.y + xyz.z;

				float x = xyz.x / xyzSum;
				float y = xyz.y / xyzSum;
				float Y = xyz.y;

				 vec3 XYyPos = vec3(x, 0.0, y);
				//vec3 XYyPos = //vec3(x, Y, y)/1.5;
	
				vec4 mvPosition = modelViewMatrix* vec4(XYyPos-vec3(.5,.5,.5), 1);
	
				gl_PointSize = 3.0;
				gl_Position = projectionMatrix * mvPosition;
	
			}
		</script>

		<script type="x-shader/x-fragment" id="CIExyYShadowFragmentShader">
			varying vec3 color;
	
			void main() {	
				vec3 newcolor = vec3(0.2,0.2,0.2);
	
				gl_FragColor = vec4( newcolor, 0.05);
			}
		</script>
		<!-- 
		uniform sampler2D tex;
		varying vec3 color;
		vec3 normalizeCIELAB(vec3 labColor) {
		float L = labColor.x / 100.0;
		float a = (labColor.y + 128.0) / 256.0;
		float b = (labColor.z + 128.0) / 256.0;
		return vec3(L, 0.0, b);
		}
		void main() {
		vec3 rgb_color = texture2D (tex, position.xy).rgb;
		float X = rgb_color.r * 0.4124564 + rgb_color.g * 0.3575761 + rgb_color.b * 0.1804375;
		float Y = rgb_color.r * 0.2126729 + rgb_color.g * 0.7151522 + rgb_color.b * 0.0721750;
		float Z = rgb_color.r * 0.0193339 + rgb_color.g * 0.1191920 + rgb_color.b * 0.9503041;
		float epsilon = 0.008856;
		float kappa = 903.3;
		float Xr = 0.950456;
		float Yr = 1.0;
		float Zr = 1.088754;
		float xr = X / Xr;
		float yr = Y / Yr;
		float zr = Z / Zr;

		float fx = xr > epsilon ? pow(xr, 1.0 / 3.0) : (kappa * xr + 16.0) / 116.0;
		float fy = yr
		} -->

		<!-- CIE LAB -->
		<script type="x-shader/x-vertex" id="CIELabVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			float f(float t) {
				float epsilon = 0.008856;
				float kappa = 903.3;
				return t > epsilon ? pow(t, 1.0 / 3.0) : (kappa * t + 16.0) / 116.0;
			}
	
			void main() {
	
				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;
				// XYZ to CIE LAB
				const vec3 refWhite = vec3(0.95047, 1.0, 1.08883);

				float xNorm = xyz.x / refWhite.x;
				float yNorm = xyz.y / refWhite.y;
				float zNorm = xyz.z / refWhite.z;

				float L = 116.0 * f(yNorm) - 16.0;
				float a = 500.0 * (f(xNorm) - f(yNorm));
				float b = 200.0 * (f(yNorm) - f(zNorm));

				float Lnorm = L / 100.0;
				float anorm = (a + 128.0) / 256.0;
				float bnorm = (b + 128.0) / 256.0;

				vec3 pos = vec3(Lnorm, anorm, bnorm);
	
				vec4 mvPosition = modelViewMatrix * vec4(pos-vec3(.5,.5,.5), 1);
	
				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
	
			}
		</script>

		<script type="x-shader/x-fragment" id="CIELabFragmentShader">
			varying vec3 color;
	
			void main() {
				gl_FragColor = vec4( color, 1.0 );
			}
		</script>

		<script type="x-shader/x-vertex" id="CIELabDensityVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			float f(float t) {
				float epsilon = 0.008856;
				float kappa = 903.3;
				return t > epsilon ? pow(t, 1.0 / 3.0) : (kappa * t + 16.0) / 116.0;
			}
	
			void main() {
	
				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;
				// XYZ to CIE LAB
				const vec3 refWhite = vec3(0.95047, 1.0, 1.08883);

				float xNorm = xyz.x / refWhite.x;
				float yNorm = xyz.y / refWhite.y;
				float zNorm = xyz.z / refWhite.z;

				float L = 116.0 * f(yNorm) - 16.0;
				float a = 500.0 * (f(xNorm) - f(yNorm));
				float b = 200.0 * (f(yNorm) - f(zNorm));

				float Lnorm = L / 100.0;
				float anorm = (a + 128.0) / 256.0;
				float bnorm = (b + 128.0) / 256.0;

				vec3 pos = vec3(Lnorm, anorm, bnorm);
	
				vec4 mvPosition = modelViewMatrix * vec4(pos-vec3(.5,.5,.5), 1);
	
				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
	
			}
		</script>

		<script type="x-shader/x-fragment" id="CIELabDensityFragmentShader">
			varying vec3 color;
	
			void main() {
				float alpha = 0.3;
				vec3 ditheredColor = color * (1.0 / 15.0) - 0.5;

				// vec3 newcolor = color * alpha;
				vec3 newColor = color + ditheredColor;
				vec3 finalColor = clamp(newColor, 0.0, 1.0);

				gl_FragColor = vec4( finalColor, alpha);
	
				//gl_FragColor = vec4( color, 1.0 );
			}
		</script>

		<script type="x-shader/x-vertex" id="CIELabShadowVertexShader">
			uniform sampler2D tex;
			varying vec3 color;

			float f(float t) {
				float epsilon = 0.008856;
				float kappa = 903.3;
				return t > epsilon ? pow(t, 1.0 / 3.0) : (kappa * t + 16.0) / 116.0;
			}
	
			void main() {
	
				color = texture2D ( tex, position.xy ).rgb;

				const mat3 rgbToXyz = mat3(
					vec3(0.4124, 0.3576, 0.1805),
					vec3(0.2126, 0.7152, 0.0722),
					vec3(0.0193, 0.1192, 0.9505)
				);

				vec3 xyz = rgbToXyz * color;
				// XYZ to CIE LAB
				const vec3 refWhite = vec3(0.95047, 1.0, 1.08883);

				float xNorm = xyz.x / refWhite.x;
				float yNorm = xyz.y / refWhite.y;
				float zNorm = xyz.z / refWhite.z;

				float L = 116.0 * f(yNorm) - 16.0;
				float a = 500.0 * (f(xNorm) - f(yNorm));
				float b = 200.0 * (f(yNorm) - f(zNorm));

				float Lnorm = L / 100.0;
				float anorm = (a + 128.0) / 256.0;
				float bnorm = (b + 128.0) / 256.0;

				vec3 pos = vec3(Lnorm, 0.0, bnorm);
	
				vec4 mvPosition = modelViewMatrix * vec4(pos-vec3(.5,.5,.5), 1);
	
				gl_PointSize = 0.015 * ( 300.0 / - mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
	
			}
		</script>

		<script type="x-shader/x-fragment" id="CIELabShadowFragmentShader">
			varying vec3 color;
	
			void main() {	
				vec3 newcolor = vec3(0.2,0.2,0.2);
	
				gl_FragColor = vec4( newcolor, 0.5);
			}
		</script>
	</div>

	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
	  {
		"imports": {
		  "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
		  "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
		}
	  }
	</script>

	<script type="module">
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { FlyControls } from 'three/addons/controls/FlyControls.js';
		import { GUI } from "three/addons/libs/lil-gui.module.min.js";
		// import WEBGL from "three/addons/capabilities/WebGL.js";

		import Stats from 'three/addons/libs/stats.module.js';

		// AR 
		import { ARButton } from 'three/addons/webxr/ARButton.js';
		import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
		import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';
		import { OculusHandPointerModel } from 'three/addons/webxr/OculusHandPointerModel.js';
		import { createText } from 'three/addons/webxr/Text2D.js';

		import { World, System, Component, TagComponent, Types } from 'three/addons/libs/ecsy.module.js';

		let container, stats;

		let camera, scene, renderer, controls;

		let points;

		let RGBVisMesh;

		var context, canvas;
		var plan, plan_ori;

		// GUI
		var gui;

		// VIDEO AND THE ASSOCIATED TEXTURE
		var video, videoTexture;

		var imageProcessing, imageProcessingMaterial;

		class Object3D extends Component { }

		Object3D.schema = {
			object: { type: Types.Ref }
		};

		class Button extends Component { }

		Button.schema = {
			// button states: [none, hovered, pressed]
			currState: { type: Types.String, default: 'none' },
			prevState: { type: Types.String, default: 'none' },
			action: { type: Types.Ref, default: () => { } }
		};

		class ButtonSystem extends System {

			execute( /*delta, time*/) {

				this.queries.buttons.results.forEach(entity => {

					const button = entity.getMutableComponent(Button);
					const buttonMesh = entity.getComponent(Object3D).object;
					if (button.currState == 'none') {

						buttonMesh.scale.set(1, 1, 1);

					} else {

						buttonMesh.scale.set(1.1, 1.1, 1.1);

					}

					if (button.currState == 'pressed' && button.prevState != 'pressed') {

						button.action();

					}

					// preserve prevState, clear currState
					// HandRaySystem will update currState
					button.prevState = button.currState;
					button.currState = 'none';

				});

			}

		}

		ButtonSystem.queries = {
			buttons: {
				components: [Button]
			}
		};

		class Draggable extends Component { }

		Draggable.schema = {
			// draggable states: [detached, hovered, to-be-attached, attached, to-be-detached]
			state: { type: Types.String, default: 'none' },
			originalParent: { type: Types.Ref, default: null },
			attachedPointer: { type: Types.Ref, default: null }
		};

		class DraggableSystem extends System {

			execute( /*delta, time*/) {

				this.queries.draggable.results.forEach(entity => {

					const draggable = entity.getMutableComponent(Draggable);
					const object = entity.getComponent(Object3D).object;
					if (draggable.originalParent == null) {

						draggable.originalParent = object.parent;

					}

					switch (draggable.state) {

						case 'to-be-attached':
							draggable.attachedPointer.children[0].attach(object);
							draggable.state = 'attached';
							break;
						case 'to-be-detached':
							draggable.originalParent.attach(object);
							draggable.state = 'detached';
							break;
						default:
							object.scale.set(1, 1, 1);

					}

				});

			}

		}

		DraggableSystem.queries = {
			draggable: {
				components: [Draggable]
			}
		};

		class Intersectable extends TagComponent { }

		class HandRaySystem extends System {

			init(attributes) {

				this.handPointers = attributes.handPointers;

			}

			execute( /*delta, time*/) {

				this.handPointers.forEach(hp => {

					let distance = null;
					let intersectingEntity = null;
					this.queries.intersectable.results.forEach(entity => {

						const object = entity.getComponent(Object3D).object;
						const intersections = hp.intersectObject(object, false);
						if (intersections && intersections.length > 0) {

							if (distance == null || intersections[0].distance < distance) {

								distance = intersections[0].distance;
								intersectingEntity = entity;

							}

						}

					});
					if (distance) {

						hp.setCursor(distance);
						if (intersectingEntity.hasComponent(Button)) {

							const button = intersectingEntity.getMutableComponent(Button);
							if (hp.isPinched()) {

								button.currState = 'pressed';

							} else if (button.currState != 'pressed') {

								button.currState = 'hovered';

							}

						}

						if (intersectingEntity.hasComponent(Draggable)) {

							const draggable = intersectingEntity.getMutableComponent(Draggable);
							const object = intersectingEntity.getComponent(Object3D).object;
							object.scale.set(1.1, 1.1, 1.1);
							if (hp.isPinched()) {

								if (!hp.isAttached() && draggable.state != 'attached') {

									draggable.state = 'to-be-attached';
									draggable.attachedPointer = hp;
									hp.setAttached(true);

								}

							} else {

								if (hp.isAttached() && draggable.state == 'attached') {

									console.log('hello');
									draggable.state = 'to-be-detached';
									draggable.attachedPointer = null;
									hp.setAttached(false);

								}

							}

						}

					} else {

						hp.setCursor(1.5);

					}

				});

			}

		}

		HandRaySystem.queries = {
			intersectable: {
				components: [Intersectable]
			}
		};

		class HandsInstructionText extends TagComponent { }

		class InstructionSystem extends System {

			init(attributes) {

				this.controllers = attributes.controllers;

			}

			execute( /*delta, time*/) {

				let visible = false;
				this.controllers.forEach(controller => {

					if (controller.visible) {

						visible = true;

					}

				});

				this.queries.instructionTexts.results.forEach(entity => {

					const object = entity.getComponent(Object3D).object;
					object.visible = visible;

				});

			}

		}

		InstructionSystem.queries = {
			instructionTexts: {
				components: [HandsInstructionText]
			}
		};

		class OffsetFromCamera extends Component { }

		OffsetFromCamera.schema = {
			x: { type: Types.Number, default: 0 },
			y: { type: Types.Number, default: 0 },
			z: { type: Types.Number, default: 0 },
		};

		class NeedCalibration extends TagComponent { }

		class CalibrationSystem extends System {

			init(attributes) {

				this.camera = attributes.camera;
				this.renderer = attributes.renderer;

			}

			execute( /*delta, time*/) {

				this.queries.needCalibration.results.forEach(entity => {

					if (this.renderer.xr.getSession()) {

						const offset = entity.getComponent(OffsetFromCamera);
						const object = entity.getComponent(Object3D).object;
						const xrCamera = this.renderer.xr.getCamera();
						object.position.x = xrCamera.position.x + offset.x;
						object.position.y = xrCamera.position.y + offset.y;
						object.position.z = xrCamera.position.z + offset.z;
						entity.removeComponent(NeedCalibration);

					}

				});

			}

		}

		CalibrationSystem.queries = {
			needCalibration: {
				components: [NeedCalibration]
			}
		};

		class Randomizable extends TagComponent { }

		class RandomizerSystem extends System {

			init( /*attributes*/) {

				this.needRandomizing = true;

			}

			execute( /*delta, time*/) {

				if (!this.needRandomizing) {

					return;

				}

				this.queries.randomizable.results.forEach(entity => {

					const object = entity.getComponent(Object3D).object;

					object.material.color.setHex(Math.random() * 0xffffff);

					object.position.x = Math.random() * 2 - 1;
					object.position.y = Math.random() * 2;
					object.position.z = Math.random() * 2 - 1;

					object.rotation.x = Math.random() * 2 * Math.PI;
					object.rotation.y = Math.random() * 2 * Math.PI;
					object.rotation.z = Math.random() * 2 * Math.PI;

					object.scale.x = Math.random() + 0.5;
					object.scale.y = Math.random() + 0.5;
					object.scale.z = Math.random() + 0.5;
					this.needRandomizing = false;

				});

			}

		}

		RandomizerSystem.queries = {
			randomizable: {
				components: [Randomizable]
			}
		};

		const world = new World();
		const clock = new THREE.Clock();

		init();
		animate();

		function init() {
			// if (WEBGL.isWebGL2Available() === false) {
			// 	document.body.appendChild(WEBGL.getWebGL2ErrorMessage());
			// }

			container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, .1, 50);
			camera.position.z = 5;

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xcccccc);


			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			if (renderer.xr.isPresenting)
				scene.background = new THREE.Color(0x000000)

			container.appendChild(renderer.domElement);

			controls = new FlyControls(camera, renderer.domElement);
			controls.dragToLook = true;
			controls.movementSpeed = 0.1;

			stats = new Stats();
			container.appendChild(stats.dom);

			const axesHelper = new THREE.AxesHelper(5);
			scene.add(axesHelper);

			const loader = new THREE.TextureLoader();

			window.addEventListener('resize', onWindowResize);

			// VR AR Content
			document.body.appendChild(ARButton.createButton(renderer));
			renderer.xr.enabled = true;
			renderer.xr.cameraAutoUpdate = false;

			// controllers
			const controller1 = renderer.xr.getController(0);
			scene.add(controller1);

			const controller2 = renderer.xr.getController(1);
			scene.add(controller2);

			const controllerModelFactory = new XRControllerModelFactory();

			// Hand 1
			const controllerGrip1 = renderer.xr.getControllerGrip(0);
			controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
			scene.add(controllerGrip1);

			const hand1 = renderer.xr.getHand(0);
			hand1.add(new OculusHandModel(hand1));
			const handPointer1 = new OculusHandPointerModel(hand1, controller1);
			hand1.add(handPointer1);

			scene.add(hand1);

			// Hand 2
			const controllerGrip2 = renderer.xr.getControllerGrip(1);
			controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
			scene.add(controllerGrip2);

			const hand2 = renderer.xr.getHand(1);
			hand2.add(new OculusHandModel(hand2));
			const handPointer2 = new OculusHandPointerModel(hand2, controller2);
			hand2.add(handPointer2);
			scene.add(hand2);

			function IVprocess(imageProcessing, renderer) {
				renderer.setRenderTarget(imageProcessing.rtt);
				renderer.render(imageProcessing.scene, imageProcessing.orthoCamera);
				renderer.setRenderTarget(null);
			}

			// WORLD
			world
				.registerComponent(Object3D)
				.registerComponent(Button)
				.registerComponent(Intersectable)
				.registerComponent(HandsInstructionText)
				.registerComponent(OffsetFromCamera)
				.registerComponent(NeedCalibration)
				.registerComponent(Randomizable)
				.registerComponent(Draggable);

			world
				.registerSystem(RandomizerSystem)
				.registerSystem(InstructionSystem, { controllers: [controllerGrip1, controllerGrip2] })
				.registerSystem(CalibrationSystem, { renderer: renderer, camera: camera })
				.registerSystem(ButtonSystem)
				.registerSystem(DraggableSystem)
				.registerSystem(HandRaySystem, { handPointers: [handPointer1, handPointer2] });


			// VIDEO AND THE ASSOCIATED TEXTURE
			var video, videoTexture;

			var imageProcessing, imageProcessingMaterial;

			video = document.createElement("video");
			video.src = "video.mp4";
			video.load();
			video.muted = true;
			video.loop = true;

			video.onloadeddata = function () {
				videoTexture = new THREE.VideoTexture(video);
				videoTexture.minFilter = THREE.NearestFilter;
				videoTexture.magFilter = THREE.NearestFilter;
				videoTexture.generateMipmaps = false;
				videoTexture.format = THREE.RGBAFormat;

				// VIDEO -------------

				var geometry2 = new THREE.PlaneGeometry(
					1,
					video.videoHeight / video.videoWidth
				);
				var material2 = new THREE.MeshBasicMaterial({
					map: videoTexture,
					side: THREE.DoubleSide,
				});
				plan_ori = new THREE.Mesh(geometry2, material2);
				plan_ori.position.z = -2.5;
				plan_ori.receiveShadow = false;
				plan_ori.castShadow = false;
				scene.add(plan_ori);


				// POINT CLOUD ------
				RGBVisMesh = new THREE.Object3D();
				var discret = 1;

				var colorSpaceMaterial = new THREE.ShaderMaterial({
					vertexShader: document.getElementById('RGBVertexShader').textContent,
					fragmentShader: document.getElementById('RGBFragmentShader').textContent,
					// blending: THREE.MultiplicativeBlending,
					depthTest: true,
					transparent: true,
					uniforms: {
						tex: { value: videoTexture },
					}
				});

				const geometry = new THREE.BufferGeometry();
				const positions = [];
				let compteur = 0;
				for (let i = 0; i < video.videoHeight; i += discret)
					for (let j = 0; j < video.videoWidth; j += discret) {
						// positions
						const x = (i + 0.5) / video.videoHeight;
						const y = (j + 0.5) / video.videoWidth;
						const z = 0;

						positions.push(x, y, z);
						compteur++;
					}

				geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
				geometry.computeBoundingSphere();

				points = new THREE.Points(geometry, colorSpaceMaterial);


				RGBVisMesh.add(points);

				var gridHelper = new THREE.GridHelper(1, 10);
				gridHelper.position.y = -0.5;
				RGBVisMesh.add(gridHelper);

				var axesHelper = new THREE.AxesHelper(1);
				axesHelper.position.set(-0.5, -0.5, -0.5)
				RGBVisMesh.add(axesHelper);

				var boundingBox = new THREE.BoxGeometry(1, 1, 1);
				var wireframe = new THREE.EdgesGeometry(boundingBox);
				var line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ color: 0xffffff }));
				line.material.depthTest = true;
				line.material.opacity = 0.5;
				line.material.linewidth = 10;
				line.material.transparent = true;
				RGBVisMesh.add(line);

				var shadowSpaceMaterial = new THREE.ShaderMaterial({
					vertexShader: document.getElementById('RGBShadowVertexShader').textContent,
					fragmentShader: document.getElementById('RGBShadowFragmentShader').textContent,
					blending: THREE.NormalBlending,
					depthTest: true,
					transparent: true,

					uniforms: {
						tex: { value: videoTexture },
					}
				});
				let shadowPoints = new THREE.Points(geometry, shadowSpaceMaterial);
				RGBVisMesh.add(shadowPoints);

				RGBVisMesh.position.x = 1;
				RGBVisMesh.position.y = -0.5;
				RGBVisMesh.position.z = -2.0
				scene.add(RGBVisMesh);

				// {
				// 	let RGBDensityVisMesh = new THREE.Object3D();

				// 	var colourDensitySpaceMaterial = new THREE.ShaderMaterial({
				// 		vertexShader: document.getElementById('RGBDensityVertexShader').textContent,
				// 		fragmentShader: document.getElementById('RGBDensityFragmentShader').textContent,
				// 		// blending: THREE.AdditiveBlending,
				// 		depthTest: true,
				// 		transparent: true,

				// 		uniforms: {
				// 			tex: { value: videoTexture },
				// 		}
				// 	});
				// 	let pointsDensity = new THREE.Points(geometry, colourDensitySpaceMaterial);
				// 	RGBDensityVisMesh.add(pointsDensity);
				// 	let shadowPoints2 = shadowPoints.clone();
				// 	RGBDensityVisMesh.add(shadowPoints2);

				// 	RGBDensityVisMesh.add(gridHelper.clone());
				// 	RGBDensityVisMesh.add(axesHelper.clone());
				// 	RGBDensityVisMesh.add(line.clone());

				// 	RGBDensityVisMesh.position.x = -1;
				// 	RGBDensityVisMesh.position.y = -0.5;

				// 	scene.add(RGBDensityVisMesh);
				// }

				// {
				// 	let CIExyYVisMesh = new THREE.Object3D();

				// 	var CIExyYSpaceMaterial = new THREE.ShaderMaterial({
				// 		vertexShader: document.getElementById('CIExyYVertexShader').textContent,
				// 		fragmentShader: document.getElementById('CIExyYFragmentShader').textContent,
				// 		// blending: THREE.AdditiveBlending,
				// 		depthTest: true,
				// 		transparent: true,

				// 		uniforms: {
				// 			tex: { value: videoTexture },
				// 		}
				// 	});

				// 	let pointsCIExyY = new THREE.Points(geometry, CIExyYSpaceMaterial);
				// 	CIExyYVisMesh.add(pointsCIExyY);


				// 	var shadowSpaceMaterial2 = new THREE.ShaderMaterial({
				// 		vertexShader: document.getElementById('CIExyYShadowVertexShader').textContent,
				// 		fragmentShader: document.getElementById('CIExyYShadowFragmentShader').textContent,
				// 		blending: THREE.NormalBlending,
				// 		depthTest: true,
				// 		transparent: true,

				// 		uniforms: {
				// 			tex: { value: videoTexture },
				// 		}
				// 	});
				// 	let shadowPoints3 = new THREE.Points(geometry, shadowSpaceMaterial2);
				// 	CIExyYVisMesh.add(shadowPoints3);

				// 	CIExyYVisMesh.add(gridHelper.clone());
				// 	CIExyYVisMesh.add(axesHelper.clone());
				// 	CIExyYVisMesh.add(line.clone());

				// 	CIExyYVisMesh.position.x = 0;
				// 	CIExyYVisMesh.position.y = 1;

				// 	scene.add(CIExyYVisMesh);

				// 	{ // CIEXYy Density
				// 		let CIExyYDensityVisMesh = new THREE.Object3D();

				// 		var CIExyYDensitySpaceMaterial = new THREE.ShaderMaterial({
				// 			vertexShader: document.getElementById('CIExyYDensityVertexShader').textContent,
				// 			fragmentShader: document.getElementById('CIExyYDensityFragmentShader').textContent,
				// 			// blending: THREE.AdditiveBlending,
				// 			depthTest: true,
				// 			transparent: true,

				// 			uniforms: {
				// 				tex: { value: videoTexture },
				// 			}
				// 		});

				// 		let pointsCIExyYDensity = new THREE.Points(geometry, CIExyYDensitySpaceMaterial);
				// 		CIExyYDensityVisMesh.add(pointsCIExyYDensity);


				// 		CIExyYDensityVisMesh.add(shadowPoints3.clone());

				// 		CIExyYDensityVisMesh.add(gridHelper.clone());
				// 		CIExyYDensityVisMesh.add(axesHelper.clone());
				// 		CIExyYDensityVisMesh.add(line.clone());

				// 		CIExyYDensityVisMesh.position.x = 0;
				// 		CIExyYDensityVisMesh.position.y = -1;

				// 		scene.add(CIExyYDensityVisMesh);
				// 	}
				// }

				// { // CIE LAB
				// 	let CIELabVisMesh = new THREE.Object3D();

				// 	var CIELabSpaceMaterial = new THREE.ShaderMaterial({
				// 		vertexShader: document.getElementById('CIELabVertexShader').textContent,
				// 		fragmentShader: document.getElementById('CIELabFragmentShader').textContent,
				// 		// blending: THREE.AdditiveBlending,
				// 		depthTest: true,
				// 		transparent: true,

				// 		uniforms: {
				// 			tex: { value: videoTexture },
				// 		}
				// 	});

				// 	let pointsCIELab = new THREE.Points(geometry, CIELabSpaceMaterial);
				// 	CIELabVisMesh.add(pointsCIELab);


				// 	var shadowSpaceMaterial2 = new THREE.ShaderMaterial({
				// 		vertexShader: document.getElementById('CIELabShadowVertexShader').textContent,
				// 		fragmentShader: document.getElementById('CIELabShadowFragmentShader').textContent,
				// 		blending: THREE.NormalBlending,
				// 		depthTest: true,
				// 		transparent: true,

				// 		uniforms: {
				// 			tex: { value: videoTexture },
				// 		}
				// 	});
				// 	let shadowPoints3 = new THREE.Points(geometry, shadowSpaceMaterial2);
				// 	CIELabVisMesh.add(shadowPoints3);

				// 	CIELabVisMesh.add(gridHelper.clone());
				// 	CIELabVisMesh.add(axesHelper.clone());
				// 	CIELabVisMesh.add(line.clone());

				// 	CIELabVisMesh.position.x = -1;
				// 	CIELabVisMesh.position.y = 1;

				// 	scene.add(CIELabVisMesh);

				// 	{ // CIELab Density
				// 		let CIELabDensityVisMesh = new THREE.Object3D();

				// 		var CIELabDensitySpaceMaterial = new THREE.ShaderMaterial({
				// 			vertexShader: document.getElementById('CIELabDensityVertexShader').textContent,
				// 			fragmentShader: document.getElementById('CIELabDensityFragmentShader').textContent,
				// 			// blending: THREE.AdditiveBlending,
				// 			depthTest: true,
				// 			transparent: true,

				// 			uniforms: {
				// 				tex: { value: videoTexture },
				// 			}
				// 		});

				// 		let pointsCIELabDensity = new THREE.Points(geometry, CIELabDensitySpaceMaterial);
				// 		CIELabDensityVisMesh.add(pointsCIELabDensity);


				// 		CIELabDensityVisMesh.add(shadowPoints3.clone());

				// 		CIELabDensityVisMesh.add(gridHelper.clone());
				// 		CIELabDensityVisMesh.add(axesHelper.clone());
				// 		CIELabDensityVisMesh.add(line.clone());

				// 		CIELabDensityVisMesh.position.x = 1;
				// 		CIELabDensityVisMesh.position.y = 1;

				// 		scene.add(CIELabDensityVisMesh);
				// 	}
				// }


				video.play();
			};


		}

		function addGUI() {
			// {//gui
			// 	var pausePlayObj = {
			// 		pausePlay: function () {
			// 			if (!video.paused) {
			// 				console.log("pause");
			// 				video.pause();
			// 			} else {
			// 				console.log("play");
			// 				video.play();
			// 			}
			// 		},
			// 		add10sec: function () {
			// 			video.currentTime = video.currentTime + 10;
			// 			console.log(video.currentTime);
			// 		},
			// 	};

			// 	gui = new GUI();
			// 	gui
			// 		.add(imageProcessingMaterial.uniforms.colorScaleR, "value", 0, 1)
			// 		.name("Red");
			// 	gui
			// 		.add(imageProcessingMaterial.uniforms.colorScaleG, "value", 0, 1)
			// 		.name("Green");
			// 	gui
			// 		.add(imageProcessingMaterial.uniforms.colorScaleB, "value", 0, 1)
			// 		.name("Blue");
			// 	gui
			// 		.add(imageProcessingMaterial.uniforms.sizeDiv2, "value", 1, 21)
			// 		.name("sizeDiv2");
			// 	gui
			// 		.add(imageProcessingMaterial.uniforms.invert, "value")
			// 		.name("Invert");
			// 	gui.add(pausePlayObj, "pausePlay").name("Pause/play video");
			// 	gui.add(pausePlayObj, "add10sec").name("Add 10 seconds");
			// }
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			// requestAnimationFrame(animate);


			controls.update(0.5);

			render();
			stats.update();
		}

		function render() {
			if (typeof imageProcessing !== "undefined")
				IVprocess(imageProcessing, renderer);
			renderer.render(scene, camera);
		}

		renderer.setAnimationLoop(animate);


	</script>

</body>

</html>